name: Update Routes Documentation

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate Routes Documentation
        env:
          BASE_URL: "https://nf.kita.blue"
        run: |
          #!/bin/bash
          set -euo pipefail

          # Utility Functions
          sanitize_path() {
            echo "$1" | tr ' ' '-' | sed -E 's/\.html$//'
          }

          get_folder_emoji() {
            local folder="$1"
            case "$folder" in
              *blog*) echo "üìù" ;;
              *docs*) echo "üìö" ;;
              *pages*) echo "üìÉ" ;;
              *api*) echo "üõ†Ô∏è" ;;
              *) echo "üìÅ" ;;
            esac
          }

          format_display_name() {
            echo "$1" | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1'
          }

          # Prepare README Template
          [[ -f README.md ]] || cat > README.md << 'EOL'
          # Project Documentation

          Welcome to our project pages.
          EOL

          # Find all directories and HTML files
          mapfile -t all_dirs < <(find . -type d | sed 's|^\./||' | sort)
          mapfile -t html_files < <(find . -type f -name "*.html" ! -path "./README.md" | sort)
          
          # Generate Routes Documentation
          {
            # Preserve content before routes section
            sed '/## üìÑ Available Routes/,$d' README.md

            # Routes Section Header
            echo -e "\n## üìÑ Available Routes\n"
            echo -e "*Last updated: $(date "+%Y-%m-%d %H:%M UTC")*\n"

            # Check if any files or folders exist
            if [[ ${#all_dirs[@]} -eq 0 && ${#html_files[@]} -eq 0 ]]; then
              echo "üöß No pages or folders available yet."
            else
              echo -e "<details>\n<summary>Click to expand routes and folders</summary>\n"
              echo -e "Browse through our project structure:\n"

              # Group HTML files by folder
              declare -A folder_files
              declare -A index_files

              for file in "${html_files[@]}"; do
                clean_path=$(sanitize_path "${file#./}")
                folder=$(dirname "$clean_path")
                basename=$(basename "$clean_path")
                
                # Track index files
                if [[ "$basename" == "index" ]]; then
                  index_files["$folder"]="$file"
                fi
                
                # Group files by folder
                [[ "$folder" == "." ]] && folder=""
                folder_files["$folder"]+="$file "
              done

              # Process all directories
              for dir in "${all_dirs[@]}"; do
                # Skip current directory and any hidden folders
                [[ "$dir" == "." || "$dir" =~ ^\. ]] && continue

                # Determine folder emoji
                folder_emoji=$(get_folder_emoji "$dir")
                
                # Check if folder has an index file
                index_route=""
                if [[ -n "${index_files[$dir]:-}" ]]; then
                  index_route="/$dir"
                fi

                # Display folder header
                echo -e "\n### ${folder_emoji} ${dir}\n"
                
                # Display index route if exists
                if [[ -n "$index_route" ]]; then
                  echo "- [üè† ${dir} Overview]($BASE_URL$index_route)"
                fi

                # Process HTML files in this folder
                if [[ -n "${folder_files[$dir]:-}" ]]; then
                  IFS=' ' read -ra dir_files <<< "${folder_files[$dir]}"
                  mapfile -t sorted_dir_files < <(printf '%s\n' "${dir_files[@]}" | sort)
                  
                  for file in "${sorted_dir_files[@]}"; do
                    # Skip index file (already displayed)
                    clean_path=$(sanitize_path "${file#./}")
                    basename=$(basename "$clean_path")
                    [[ "$basename" == "index" ]] && continue

                    # Generate route for other files
                    display_name=$(format_display_name "$basename")
                    echo "- [üìÑ $display_name]($BASE_URL/$clean_path)"
                  done
                fi
              done

              # Handle root directory separately
              root_files="${folder_files[.]:-}"
              if [[ -n "${index_files[.]:-}" || -n "$root_files" ]]; then
                echo -e "\n### üè† Root\n"
                
                # Display root index if exists
                if [[ -n "${index_files[.]:-}" ]]; then
                  echo "- [üè† Homepage]($BASE_URL/)"
                fi

                # Process root HTML files
                if [[ -n "$root_files" ]]; then
                  IFS=' ' read -ra root_file_list <<< "$root_files"
                  mapfile -t sorted_root_files < <(printf '%s\n' "${root_file_list[@]}" | sort)
                  
                  for file in "${sorted_root_files[@]}"; do
                    # Skip root index file
                    clean_path=$(sanitize_path "${file#./}")
                    basename=$(basename "$clean_path")
                    [[ "$basename" == "index" ]] && continue

                    # Generate route for root files
                    display_name=$(format_display_name "$basename")
                    echo "- [üìÑ $display_name]($BASE_URL/$clean_path)"
                  done
                fi
              fi

              echo -e "\n</details>"

              # Stats Footer
              echo -e "\n---\n"
              folder_count=$((${#all_dirs[@]} - 1))  # Subtract 1 to exclude root
              file_count=${#html_files[@]}
              echo "üìä **Stats**: $file_count page(s) in $folder_count folder(s)"
              echo -e "\nüí° *Routes auto-updated on page changes.*"
            fi
          } > README.new

          # Update README only if changes exist
          if ! cmp -s README.md README.new; then
            mv README.new README.md
            echo "should_commit=true" >> "$GITHUB_ENV"
          else
            rm README.new
            echo "should_commit=false" >> "$GITHUB_ENV"
          fi

      - name: Commit Changes
        if: env.should_commit == 'true'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add README.md
          git commit -m "üìù Update routes documentation [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}