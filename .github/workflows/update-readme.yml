name: Update Routes Documentation

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate Routes Documentation
        env:
          BASE_URL: "https://nf.kita.blue"
        run: |
          #!/bin/bash
          set -euo pipefail

          # Utility Functions
          sanitize_path() { 
            echo "$1" | tr ' ' '-' | sed -E 's/\.html$//' 
          }

          get_folder_emoji() {
            local path="$1"
            case "$path" in
              *praktikum*) echo "üî¨" ;;
              *pertemuan*) echo "üìÖ" ;;
              *tugas*) echo "üìã" ;;
              *docs*) echo "üìö" ;;
              *src*) echo "üíª" ;;
              *test*) echo "üß™" ;;
              *) echo "üìÅ" ;;
            esac
          }

          format_display_name() { 
            echo "$1" | 
              sed 's/-/ /g' | 
              awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1'
          }

          # Prepare README
          [[ -f README.md ]] || echo "# Project Documentation" > README.md

          # Find HTML files and exclude hidden paths
          mapfile -t html_files < <(find . -type f -name "*.html" ! -path "./README.md" ! -path '*/\.*' | sort)
          [[ ${#html_files[@]} -eq 0 ]] && exit 0

          {
            # Preserve existing content before routes section
            sed '/## üìÑ Available Routes/,$d' README.md

            # Routes section header
            echo -e "\n## üìÑ Available Routes\n"
            echo -e "*Last updated: $(date "+%Y-%m-%d %H:%M UTC")*\n"

            echo -e "<details open>\n<summary>üóÇÔ∏è Project Structure</summary>\n"

            # Recursive directory processing function
            process_directory() {
              local base_path="$1"
              local indent="${2:-}"
              local depth="${3:-0}"

              # Find files, prioritize index.html
              local index_files=$(find "$base_path" -maxdepth 1 -type f -name "index.html")
              local other_files=$(find "$base_path" -maxdepth 1 -type f -name "*.html" ! -name "index.html")
              local subdirs=$(find "$base_path" -maxdepth 1 -type d ! -path '*/\.*' | tail -n +2 | sort)

              # Process only if files or subdirectories exist
              if [[ -n "$index_files$other_files$subdirs" ]]; then
                local folder_emoji=$(get_folder_emoji "$base_path")
                local relative_path="${base_path#./}"

                # Print directory header with appropriate indentation
                case $depth in
                  0) echo "${indent}### ${folder_emoji} ${relative_path}" ;;
                  1) echo "${indent}#### ${folder_emoji} ${relative_path}" ;;
                  *) echo "${indent}##### ${folder_emoji} ${relative_path}" ;;
                esac
                echo ""

                # Prioritize and list index files first
                for index_file in $index_files; do
                  local clean_path=$(sanitize_path "${index_file#./}")
                  echo "${indent}- [üè† Overview]($BASE_URL/$clean_path)"
                done

                # List other files, sorted and formatted
                for file in $other_files; do
                  local clean_path=$(sanitize_path "${file#./}")
                  local basename=$(basename "$clean_path" .html)
                  local display_name=$(format_display_name "$basename")
                  echo "${indent}- [üìÑ $display_name]($BASE_URL/$clean_path)"
                done

                # Recursively process subdirectories
                for subdir in $subdirs; do
                  process_directory "$subdir" "$indent  " $((depth + 1))
                done
              fi
            }

            # Start processing from root
            process_directory "."

            echo -e "\n</details>\n---\n"
            
            # Project statistics
            total_dirs=$(find . -type d ! -path '*/\.*' | wc -l)
            echo "üìä **Project Stats**:"
            echo "- üìÑ Pages: ${#html_files[@]}"
            echo "- üìÇ Folders: $((total_dirs - 1))"
            echo -e "\nüí° *Automatically updated on page changes.*"
          } > README.new

          # Update README only if changes exist
          if ! cmp -s README.md README.new; then
            mv README.new README.md
            echo "should_commit=true" >> "$GITHUB_ENV"
          else
            rm README.new
            echo "should_commit=false" >> "$GITHUB_ENV"
          fi

      - name: Commit Changes
        if: env.should_commit == 'true'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add README.md
          git commit -m "üìù Update routes documentation [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
