name: Update Routes Documentation

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate Routes Documentation
        env:
          BASE_URL: "https://nf.kita.blue"
        run: |
          #!/bin/bash
          set -euo pipefail

          # Utility functions
          sanitize_path() { 
            echo "$1" | tr ' ' '-' | sed -E 's/\.html$//'
          }

          get_folder_emoji() {
            local path="$1"
            case "$path" in
              *docs*) echo "üìö" ;;
              *src*) echo "üíª" ;;
              *test*) echo "üß™" ;;
              *build*) echo "üèóÔ∏è" ;;
              *script*) echo "üîß" ;;
              *config*) echo "‚öôÔ∏è" ;;
              *) echo "üìÅ" ;;
            esac
          }

          format_display_name() { 
            echo "$1" | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1'
          }

          # Create README if not exists
          [[ -f README.md ]] || echo "# Project Documentation" > README.md

          # Find all HTML files, excluding README and hidden paths
          mapfile -t all_html_files < <(find . -type f -name "*.html" ! -path "./README.md" ! -path '*/\.*' | sort)

          # Exit if no files found
          [[ ${#all_html_files[@]} -eq 0 ]] && exit 0

          {
            # Preserve content before routes section
            sed '/## üìÑ Available Routes/,$d' README.md

            # Routes section header
            echo -e "\n## üìÑ Available Routes\n"
            echo -e "*Last updated: $(date "+%Y-%m-%d %H:%M UTC")*\n"

            echo -e "<details>\n<summary>Click to expand routes and folders</summary>\n"

            # Declare a function to process directories recursively
            process_directory() {
              local base_path="$1"
              local indent="${2:-}"
              local depth="${3:-0}"

              # Find index and other files in this directory
              local index_file=$(find "$base_path" -maxdepth 1 -type f -name "index.html")
              local other_files=$(find "$base_path" -maxdepth 1 -type f -name "*.html" ! -name "index.html")
              local subdirs=$(find "$base_path" -maxdepth 1 -type d ! -path '*/\.*' | tail -n +2)

              # Only process if there are files or subdirectories
              if [[ -n "$index_file$other_files$subdirs" ]]; then
                # Get folder emoji
                local folder_emoji=$(get_folder_emoji "$base_path")
                local relative_path="${base_path#./}"

                # Print directory header
                if [[ "$depth" -gt 0 ]]; then
                  echo "${indent}#### ${folder_emoji} ${relative_path}"
                else
                  echo "${indent}### ${folder_emoji} ${relative_path}"
                fi
                echo ""

                # Print index route if exists
                if [[ -n "$index_file" ]]; then
                  echo "${indent}- [üè† ${relative_path##*/}]($BASE_URL/${relative_path})"
                fi

                # Process other files in this directory
                if [[ -n "$other_files" ]]; then
                  while IFS= read -r file; do
                    local clean_path=$(sanitize_path "${file#./}")
                    local basename=$(basename "$clean_path" .html)
                    local display_name=$(format_display_name "$basename")
                    echo "${indent}- [üìÑ $display_name]($BASE_URL/$clean_path)"
                  done <<< "$other_files"
                fi

                # Recursively process subdirectories
                if [[ -n "$subdirs" ]]; then
                  while IFS= read -r subdir; do
                    process_directory "$subdir" "$indent  " $((depth + 1))
                  done <<< "$subdirs"
                fi
              fi
            }

            # Start processing from root
            process_directory "."

            echo -e "\n</details>\n---\n"
            echo "üìä **Stats**: ${#all_html_files[@]} page(s)"
            echo -e "\nüí° *Routes auto-updated on page changes.*"
          } > README.new

          # Update README only if changes exist
          if ! cmp -s README.md README.new; then
            mv README.new README.md
            echo "should_commit=true" >> "$GITHUB_ENV"
          else
            rm README.new
            echo "should_commit=false" >> "$GITHUB_ENV"
          fi

      - name: Commit Changes
        if: env.should_commit == 'true'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add README.md
          git commit -m "üìù Update routes documentation [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
